---
layout: post
title: network-http1.1优化
date: 2021-07-28
tags: zyb_note 
---

<h2 align="center">HTTP1.1优化</h2>

主要有三个思路来优化HTTP1.1协议，比如有三种思路来实现。

- 尽量避免发送HTTP请求
- 在需要发送HTTP请求的时候，考虑如何减少请求次数
- 减少服务器的HTTP响应数据大小

下面就针对这三种思路具体看看有哪些优化的方法。



## 一、尽量避免发送请求

缓存技术，客户端会把第一次请求以及其响应的数据保存在本地磁盘中，其中可以将通过key:value的形式去保存缓存的数据。

### 1.1 强制缓存，协商缓存的关系与区别：

浏览器第一次打开一个网页获取资源后，根据返回的header信息来告诉如何缓存资源。浏览器第一次请求。

![PCB_management](/images/network/requestFirst.png)

![img](https://images2015.cnblogs.com/blog/408483/201605/408483-20160525182843100-1556227104.png)

浏览器发送请求，无缓存的情况下，请求响应之后，根据响应的头部告诉我们如何进行缓存。1.expires 有效期至什么时候。2 cache-control  3.Etag    4.last-modified

![image](https://images2015.cnblogs.com/blog/408483/201605/408483-20160525182943272-204994049.png)

 在后续的请求中，在发送之前，会首先检查本地缓存，是否含有该请求的结果。如果有的话，就先去检查其头部是否命中强制缓存（Expires 、cache-control），若命中直接从缓存中获取资源信息，包括缓存header信息，本次请求就不会与服务器进行通信。如果没有命中的话，就会发送网络请求，但是在发送的时候需要带上其头部有关的字段（Etag/If-none-match  和  Last-modified/If-modified-since）由服务器来判断是否命中协商缓存，如果命中的话，就返回一个 304 not modified，那么客户端直接从缓存中获取数据，如果返回了新的数据，那么就在缓存中更新相关的信息。

### 强制缓存相关字段

##### Expires策略：

expires是web服务器中响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。Expires设置失效时间，精确到时分秒。不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。

##### Cache-control策略：

cache-control与Expires的作用一致，都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存拿到数据还是从服务器端去获取数据。只不过Cache-control的选项更多一些，设置更加精细，如果同时设置的话，其优先级高于Expires。

Http协议头：Cache-control 其value可以为 `private`、 `no-cache` 、`no-store`、 `no-transform`、 `must-revalidate` 、`proxy-revalidate` 、`max-age`

各个消息中的指令含义如下：

1. Public指示响应可被任何缓存区缓存。
2. private指示对于单个用户的整个或者部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述用户的部分响应消息，此相应消息对于其他用户的请求无效。
3. no-cache代表不缓存过期的资源，缓存会向服务器进行有效处理确认之后处理资源，do-not-serve-from-cache-without-revalidation
4. no-store表示全面禁止缓存。
5. max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。

**如果cache-control与expires同时存在的话，cache-control的优先级高于expires**

### 协商缓存的相关字段

Last-modified/If-Modified-since 和 Etag/If-None-Match 这两组搭档是成对出现的，也就说第一次请求中出现了Last-modified，那么接下来的请求中就会带上If-Modified-Since字段，如果第一次请求中带有Etag字段的话，那么接下来的请求中就会带有If-None-Match字段。

这两个字段都需要配合Cache-control来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求。

Last-modified/If-Modified-since

- last-modified：标示这个响应资源的最后修改时间。web服务器在响应请求的时候，告诉服务器的请求最终修改时间。
- If-modified-since：当资源过期了，发现响应头中具有last-modified声明，则再次发起请求的时候带上last-modified的时间，服务器收到请求后发现有if-modified-since则与被请求资源的最后修改时间进行对比（Last-Modified）,若最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK;若最后修改时间较旧（小），说明资源无新修改，响应HTTP 304 走缓存。

Etag/If-None-Match

- Etag：服务器响应时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。
- If-None-Match：当资源过期时，浏览器发现响应头里有Etag,则再次像服务器请求时带上请求头`if-none-match`(值是Etag的值)。服务器收到请求进行比对，决定返回200或304。



### Etag和Last-modified两者为何并存？

看上去两者的功能很是相似都是为了实现协商缓存，Etag的出现主要目的是为了解决几个Last-modified不好解决的问题。

因为有的文件是周期性变化的，对于客户端来说意义不大，不需要客户端去检测到它的变化，所以采用大的版本控制的方式去检测就可以了。这时，利用Etag能够更加准确的控制缓存，因为Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符。

**Etag和last-modified同时存在的时候Etag的优先级更高**

## 二、尽量减少HTTP请求次数

- 尽量减少重定向次数
- 合并请求
- 延迟发送请求

### 尽量减少重定向次数

减少重定向次数，服务器上的一个资源可能由于迁移、维护等原因从url转移到url2后，而客户端并不知道，客户端此时并不会不会简单粗暴的返回错误，而是通过302响应码和Location头部，告诉客户端该资源已经迁移到url2上了，于是客户端需要再次发送url2请求以获取到服务器资源。那么如果重定向的次数过多了，每次客户端都要多次发起HTTP请求，每一次的HTTP请求得经过网络，这无疑会降低网络性能。

301: Moved Permanently  资源永久重定向到另外一个URI

302: Found/Moved Temporarily 资源临时重定向到另外一个URI中



### 合并请求

可以将多个小文件的请求合并为一个大的请求，虽然传输的总资源是一定的，但是减少了请求的次数，这就意味着减少了重复发送HTTP头部。



### 延迟发送请求

图片懒加载等等。



## 三、减小HTTP响应的数据大小

减少HTTP响应数据的大小，从而提高网络传输的效率。对数据进行压缩。
