

<h2 align="center">JS 中的 作用域、作用域链、内存闭包等相关概念</h2>

### 1.作用域

#### 1.1 函数作用域和全局作用域

在JS中一般只有全局作用域和函数作用域。大家应该非常熟悉函数作用域了,下面就来展示一下函数作用域和全局作用域。

```javascript
function foo(){
	var a = "bar"
	console.log(a)
}
foo()
// bar
// 这个时候 a 在 foo 函数作用域内

=============>

var b = "bar"
function foo(){
	console.log(b)
}
foo()
// bar
// 这个时候 b 就在全局作用域中，foo 函数中没有 b 这个变量，然后就到上一层的全局作用域中去寻找 b。得出来 bar

==============》

function bar(){
	var b = "bar"
}
function foo(){
	console.log(b)
}
foo()
// Uncaught ReferenceError: b is not defined
// 这个时候呢，在 foo 函数作用域中没有找到 b，然后就去外层作用域中（全局作用域）去寻找 b，但是我们发现没有b 这个变量。然后就会报错。
```

简单来说，在JS执行的某一个函数时，就会就近取值。如果在当前函数作用域中没有找到该变量的时候就去上一层的作用域中去寻找。

#### 1.2 块级作用域和暂时性死区

随着JS的发展，ES6中增加了let和const生命声明的块级作用域，使得JS中的作用域更加丰富，同时也出现一个暂时性死区（TDZ），后面都会讲到。

```javascript
function foo(){
	console.log(bar)
	var bar = 3
}
foo()

// undefined
// 这个时候代码会输出 undefinede，原因是变量 bar 在函数内部进行了提升了。

==========>

// 上面的代码等同于
function foo(){
  var bar 
  console.log(bar)
  bar = 3
}

==========>

// 但是在使用 let 和 const 进行声明的时候，则会产生 Uncaught ReferenceError: bar is not defined.
function foo(){
  console.log(bar)
  let bar = 3
}
// 这个时候会报错。

==========>

function(){
  let var = 3
	console.log(bar)
}
// 这个时候就不会报错了，因为这个时候就不在暂时性死区里面了，就不会存在引用报错了。
// 对于TDZ这个概念，在相应的花括号形成的作用域中存在一个“死区”，起始于函数开头，终止于相关函数的声明所在行。就像
function foo(){
  console.log(bar)
  let bar = 3
}
// 这个函数，console.log的时候就在TDZ中，但是TDZ终止于let bar = 3这一行。
```

此外对于TDZ还有一个特殊的情况就是在函数参数的默认值的用法中。（这个地方等到后面补充）

